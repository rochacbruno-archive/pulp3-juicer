# coding: utf-8

"""
    Pulp3 API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from juicer.api_client import ApiClient


class PulpApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def artifacts_create(self, data, **kwargs):  # noqa: E501
        """artifacts_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Artifact data: (required)
        :return: Artifact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.artifacts_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.artifacts_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def artifacts_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """artifacts_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Artifact data: (required)
        :return: Artifact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method artifacts_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `artifacts_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/artifacts/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Artifact',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def artifacts_delete(self, artifact_href, **kwargs):  # noqa: E501
        """artifacts_delete  # noqa: E501

        Remove Artifact only if it is not associated with any Content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_delete(artifact_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str artifact_href: URI of Artifact. e.g.: /pulp/api/v3/artifacts/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.artifacts_delete_with_http_info(artifact_href, **kwargs)  # noqa: E501
        else:
            (data) = self.artifacts_delete_with_http_info(artifact_href, **kwargs)  # noqa: E501
            return data

    def artifacts_delete_with_http_info(self, artifact_href, **kwargs):  # noqa: E501
        """artifacts_delete  # noqa: E501

        Remove Artifact only if it is not associated with any Content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_delete_with_http_info(artifact_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str artifact_href: URI of Artifact. e.g.: /pulp/api/v3/artifacts/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['artifact_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method artifacts_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'artifact_href' is set
        if ('artifact_href' not in params or
                params['artifact_href'] is None):
            raise ValueError("Missing the required parameter `artifact_href` when calling `artifacts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'artifact_href' in params:
            path_params['artifact_href'] = params['artifact_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{artifact_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def artifacts_list(self, **kwargs):  # noqa: E501
        """artifacts_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str md5: Filter results where md5 matches value
        :param str sha1: Filter results where sha1 matches value
        :param str sha224: Filter results where sha224 matches value
        :param str sha256: Filter results where sha256 matches value
        :param str sha384: Filter results where sha384 matches value
        :param str sha512: Filter results where sha512 matches value
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.artifacts_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.artifacts_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def artifacts_list_with_http_info(self, **kwargs):  # noqa: E501
        """artifacts_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str md5: Filter results where md5 matches value
        :param str sha1: Filter results where sha1 matches value
        :param str sha224: Filter results where sha224 matches value
        :param str sha256: Filter results where sha256 matches value
        :param str sha384: Filter results where sha384 matches value
        :param str sha512: Filter results where sha512 matches value
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method artifacts_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'sha1' in params:
            query_params.append(('sha1', params['sha1']))  # noqa: E501
        if 'sha224' in params:
            query_params.append(('sha224', params['sha224']))  # noqa: E501
        if 'sha256' in params:
            query_params.append(('sha256', params['sha256']))  # noqa: E501
        if 'sha384' in params:
            query_params.append(('sha384', params['sha384']))  # noqa: E501
        if 'sha512' in params:
            query_params.append(('sha512', params['sha512']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/artifacts/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def artifacts_read(self, artifact_href, **kwargs):  # noqa: E501
        """artifacts_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_read(artifact_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str artifact_href: URI of Artifact. e.g.: /pulp/api/v3/artifacts/1/ (required)
        :return: Artifact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.artifacts_read_with_http_info(artifact_href, **kwargs)  # noqa: E501
        else:
            (data) = self.artifacts_read_with_http_info(artifact_href, **kwargs)  # noqa: E501
            return data

    def artifacts_read_with_http_info(self, artifact_href, **kwargs):  # noqa: E501
        """artifacts_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.artifacts_read_with_http_info(artifact_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str artifact_href: URI of Artifact. e.g.: /pulp/api/v3/artifacts/1/ (required)
        :return: Artifact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['artifact_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method artifacts_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'artifact_href' is set
        if ('artifact_href' not in params or
                params['artifact_href'] is None):
            raise ValueError("Missing the required parameter `artifact_href` when calling `artifacts_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'artifact_href' in params:
            path_params['artifact_href'] = params['artifact_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{artifact_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Artifact',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_blobs_create(self, data, **kwargs):  # noqa: E501
        """content_docker_blobs_create  # noqa: E501

        Create a new ManifestBlob from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_blobs_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Blob data: (required)
        :return: Blob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_blobs_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_blobs_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_docker_blobs_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_docker_blobs_create  # noqa: E501

        Create a new ManifestBlob from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_blobs_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Blob data: (required)
        :return: Blob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_blobs_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_docker_blobs_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/blobs/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Blob',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_blobs_list(self, **kwargs):  # noqa: E501
        """content_docker_blobs_list  # noqa: E501

        ViewSet for ManifestBlobs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_blobs_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_blobs_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_blobs_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_docker_blobs_list_with_http_info(self, **kwargs):  # noqa: E501
        """content_docker_blobs_list  # noqa: E501

        ViewSet for ManifestBlobs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_blobs_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_blobs_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/blobs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_blobs_read(self, manifest_blob_href, **kwargs):  # noqa: E501
        """content_docker_blobs_read  # noqa: E501

        ViewSet for ManifestBlobs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_blobs_read(manifest_blob_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_blob_href: URI of Manifest Blob. e.g.: /pulp/api/v3/content/docker/blobs/1/ (required)
        :return: Blob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_blobs_read_with_http_info(manifest_blob_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_blobs_read_with_http_info(manifest_blob_href, **kwargs)  # noqa: E501
            return data

    def content_docker_blobs_read_with_http_info(self, manifest_blob_href, **kwargs):  # noqa: E501
        """content_docker_blobs_read  # noqa: E501

        ViewSet for ManifestBlobs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_blobs_read_with_http_info(manifest_blob_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_blob_href: URI of Manifest Blob. e.g.: /pulp/api/v3/content/docker/blobs/1/ (required)
        :return: Blob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest_blob_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_blobs_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest_blob_href' is set
        if ('manifest_blob_href' not in params or
                params['manifest_blob_href'] is None):
            raise ValueError("Missing the required parameter `manifest_blob_href` when calling `content_docker_blobs_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manifest_blob_href' in params:
            path_params['manifest_blob_href'] = params['manifest_blob_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{manifest_blob_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Blob',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_list_tags_create(self, data, **kwargs):  # noqa: E501
        """content_docker_manifest_list_tags_create  # noqa: E501

        Create a new ManifestListTag from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_list_tags_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManifestListTag data: (required)
        :return: ManifestListTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_list_tags_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_list_tags_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_docker_manifest_list_tags_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_docker_manifest_list_tags_create  # noqa: E501

        Create a new ManifestListTag from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_list_tags_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManifestListTag data: (required)
        :return: ManifestListTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_list_tags_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_docker_manifest_list_tags_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifest-list-tags/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManifestListTag',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_list_tags_list(self, **kwargs):  # noqa: E501
        """content_docker_manifest_list_tags_list  # noqa: E501

        ViewSet for ManifestListTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_list_tags_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_list_tags_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_list_tags_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_docker_manifest_list_tags_list_with_http_info(self, **kwargs):  # noqa: E501
        """content_docker_manifest_list_tags_list  # noqa: E501

        ViewSet for ManifestListTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_list_tags_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_list_tags_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifest-list-tags/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_list_tags_read(self, manifest_list_tag_href, **kwargs):  # noqa: E501
        """content_docker_manifest_list_tags_read  # noqa: E501

        ViewSet for ManifestListTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_list_tags_read(manifest_list_tag_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_list_tag_href: URI of Manifest List Tag. e.g.: /pulp/api/v3/content/docker/manifest-list-tags/1/ (required)
        :return: ManifestListTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_list_tags_read_with_http_info(manifest_list_tag_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_list_tags_read_with_http_info(manifest_list_tag_href, **kwargs)  # noqa: E501
            return data

    def content_docker_manifest_list_tags_read_with_http_info(self, manifest_list_tag_href, **kwargs):  # noqa: E501
        """content_docker_manifest_list_tags_read  # noqa: E501

        ViewSet for ManifestListTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_list_tags_read_with_http_info(manifest_list_tag_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_list_tag_href: URI of Manifest List Tag. e.g.: /pulp/api/v3/content/docker/manifest-list-tags/1/ (required)
        :return: ManifestListTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest_list_tag_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_list_tags_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest_list_tag_href' is set
        if ('manifest_list_tag_href' not in params or
                params['manifest_list_tag_href'] is None):
            raise ValueError("Missing the required parameter `manifest_list_tag_href` when calling `content_docker_manifest_list_tags_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manifest_list_tag_href' in params:
            path_params['manifest_list_tag_href'] = params['manifest_list_tag_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{manifest_list_tag_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManifestListTag',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_lists_create(self, data, **kwargs):  # noqa: E501
        """content_docker_manifest_lists_create  # noqa: E501

        Create a new ManifestList from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_lists_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManifestList data: (required)
        :return: ManifestList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_lists_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_lists_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_docker_manifest_lists_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_docker_manifest_lists_create  # noqa: E501

        Create a new ManifestList from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_lists_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManifestList data: (required)
        :return: ManifestList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_lists_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_docker_manifest_lists_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifest-lists/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManifestList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_lists_list(self, **kwargs):  # noqa: E501
        """content_docker_manifest_lists_list  # noqa: E501

        ViewSet for ManifestList.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_lists_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_lists_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_lists_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_docker_manifest_lists_list_with_http_info(self, **kwargs):  # noqa: E501
        """content_docker_manifest_lists_list  # noqa: E501

        ViewSet for ManifestList.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_lists_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_lists_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifest-lists/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_lists_read(self, manifest_list_href, **kwargs):  # noqa: E501
        """content_docker_manifest_lists_read  # noqa: E501

        ViewSet for ManifestList.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_lists_read(manifest_list_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_list_href: URI of Manifest List. e.g.: /pulp/api/v3/content/docker/manifest-lists/1/ (required)
        :return: ManifestList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_lists_read_with_http_info(manifest_list_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_lists_read_with_http_info(manifest_list_href, **kwargs)  # noqa: E501
            return data

    def content_docker_manifest_lists_read_with_http_info(self, manifest_list_href, **kwargs):  # noqa: E501
        """content_docker_manifest_lists_read  # noqa: E501

        ViewSet for ManifestList.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_lists_read_with_http_info(manifest_list_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_list_href: URI of Manifest List. e.g.: /pulp/api/v3/content/docker/manifest-lists/1/ (required)
        :return: ManifestList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest_list_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_lists_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest_list_href' is set
        if ('manifest_list_href' not in params or
                params['manifest_list_href'] is None):
            raise ValueError("Missing the required parameter `manifest_list_href` when calling `content_docker_manifest_lists_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manifest_list_href' in params:
            path_params['manifest_list_href'] = params['manifest_list_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{manifest_list_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManifestList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_tags_create(self, data, **kwargs):  # noqa: E501
        """content_docker_manifest_tags_create  # noqa: E501

        Create a new ManifestTag from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_tags_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManifestTag data: (required)
        :return: ManifestTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_tags_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_tags_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_docker_manifest_tags_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_docker_manifest_tags_create  # noqa: E501

        Create a new ManifestTag from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_tags_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param ManifestTag data: (required)
        :return: ManifestTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_tags_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_docker_manifest_tags_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifest-tags/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManifestTag',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_tags_list(self, **kwargs):  # noqa: E501
        """content_docker_manifest_tags_list  # noqa: E501

        ViewSet for ManifestTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_tags_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_tags_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_tags_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_docker_manifest_tags_list_with_http_info(self, **kwargs):  # noqa: E501
        """content_docker_manifest_tags_list  # noqa: E501

        ViewSet for ManifestTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_tags_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_tags_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifest-tags/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifest_tags_read(self, manifest_tag_href, **kwargs):  # noqa: E501
        """content_docker_manifest_tags_read  # noqa: E501

        ViewSet for ManifestTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_tags_read(manifest_tag_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_tag_href: URI of Manifest Tag. e.g.: /pulp/api/v3/content/docker/manifest-tags/1/ (required)
        :return: ManifestTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifest_tags_read_with_http_info(manifest_tag_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifest_tags_read_with_http_info(manifest_tag_href, **kwargs)  # noqa: E501
            return data

    def content_docker_manifest_tags_read_with_http_info(self, manifest_tag_href, **kwargs):  # noqa: E501
        """content_docker_manifest_tags_read  # noqa: E501

        ViewSet for ManifestTag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifest_tags_read_with_http_info(manifest_tag_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str manifest_tag_href: URI of Manifest Tag. e.g.: /pulp/api/v3/content/docker/manifest-tags/1/ (required)
        :return: ManifestTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['manifest_tag_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifest_tags_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'manifest_tag_href' is set
        if ('manifest_tag_href' not in params or
                params['manifest_tag_href'] is None):
            raise ValueError("Missing the required parameter `manifest_tag_href` when calling `content_docker_manifest_tags_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'manifest_tag_href' in params:
            path_params['manifest_tag_href'] = params['manifest_tag_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{manifest_tag_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ManifestTag',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifests_create(self, data, **kwargs):  # noqa: E501
        """content_docker_manifests_create  # noqa: E501

        Create a new Manifest from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifests_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Manifest data: (required)
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifests_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifests_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_docker_manifests_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_docker_manifests_create  # noqa: E501

        Create a new Manifest from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifests_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Manifest data: (required)
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifests_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_docker_manifests_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifests/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manifest',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifests_list(self, **kwargs):  # noqa: E501
        """content_docker_manifests_list  # noqa: E501

        ViewSet for Manifest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifests_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifests_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifests_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_docker_manifests_list_with_http_info(self, **kwargs):  # noqa: E501
        """content_docker_manifests_list  # noqa: E501

        ViewSet for Manifest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifests_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifests_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/docker/manifests/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_docker_manifests_read(self, image_manifest_href, **kwargs):  # noqa: E501
        """content_docker_manifests_read  # noqa: E501

        ViewSet for Manifest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifests_read(image_manifest_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str image_manifest_href: URI of Image Manifest. e.g.: /pulp/api/v3/content/docker/manifests/1/ (required)
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_docker_manifests_read_with_http_info(image_manifest_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_docker_manifests_read_with_http_info(image_manifest_href, **kwargs)  # noqa: E501
            return data

    def content_docker_manifests_read_with_http_info(self, image_manifest_href, **kwargs):  # noqa: E501
        """content_docker_manifests_read  # noqa: E501

        ViewSet for Manifest.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_docker_manifests_read_with_http_info(image_manifest_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str image_manifest_href: URI of Image Manifest. e.g.: /pulp/api/v3/content/docker/manifests/1/ (required)
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image_manifest_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_docker_manifests_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image_manifest_href' is set
        if ('image_manifest_href' not in params or
                params['image_manifest_href'] is None):
            raise ValueError("Missing the required parameter `image_manifest_href` when calling `content_docker_manifests_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'image_manifest_href' in params:
            path_params['image_manifest_href'] = params['image_manifest_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{image_manifest_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manifest',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_file_files_create(self, data, **kwargs):  # noqa: E501
        """content_file_files_create  # noqa: E501

        ViewSet for FileContent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_file_files_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param FileContent data: (required)
        :return: FileContent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_file_files_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_file_files_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_file_files_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_file_files_create  # noqa: E501

        ViewSet for FileContent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_file_files_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param FileContent data: (required)
        :return: FileContent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_file_files_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_file_files_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/file/files/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileContent',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_file_files_list(self, **kwargs):  # noqa: E501
        """content_file_files_list  # noqa: E501

        ViewSet for FileContent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_file_files_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str relative_path: Filter results where relative_path matches value
        :param str digest: Filter results where digest matches value
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_file_files_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_file_files_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_file_files_list_with_http_info(self, **kwargs):  # noqa: E501
        """content_file_files_list  # noqa: E501

        ViewSet for FileContent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_file_files_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str relative_path: Filter results where relative_path matches value
        :param str digest: Filter results where digest matches value
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['relative_path', 'digest', 'repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_file_files_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'relative_path' in params:
            query_params.append(('relative_path', params['relative_path']))  # noqa: E501
        if 'digest' in params:
            query_params.append(('digest', params['digest']))  # noqa: E501
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/file/files/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_file_files_read(self, file_content_href, **kwargs):  # noqa: E501
        """content_file_files_read  # noqa: E501

        ViewSet for FileContent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_file_files_read(file_content_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_content_href: URI of File Content. e.g.: /pulp/api/v3/content/file/files/1/ (required)
        :return: FileContent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_file_files_read_with_http_info(file_content_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_file_files_read_with_http_info(file_content_href, **kwargs)  # noqa: E501
            return data

    def content_file_files_read_with_http_info(self, file_content_href, **kwargs):  # noqa: E501
        """content_file_files_read  # noqa: E501

        ViewSet for FileContent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_file_files_read_with_http_info(file_content_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_content_href: URI of File Content. e.g.: /pulp/api/v3/content/file/files/1/ (required)
        :return: FileContent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_content_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_file_files_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_content_href' is set
        if ('file_content_href' not in params or
                params['file_content_href'] is None):
            raise ValueError("Missing the required parameter `file_content_href` when calling `content_file_files_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_content_href' in params:
            path_params['file_content_href'] = params['file_content_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_content_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileContent',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_rpm_errata_create(self, data, **kwargs):  # noqa: E501
        """A ViewSet for UpdateRecord.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/errata/  Also specify queryset and serializer for UpdateRecord.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_errata_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param UpdateRecord data: (required)
        :return: UpdateRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_rpm_errata_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_rpm_errata_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_rpm_errata_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """A ViewSet for UpdateRecord.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/errata/  Also specify queryset and serializer for UpdateRecord.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_errata_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param UpdateRecord data: (required)
        :return: UpdateRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_rpm_errata_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_rpm_errata_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/rpm/errata/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateRecord',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_rpm_errata_list(self, **kwargs):  # noqa: E501
        """A ViewSet for UpdateRecord.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/errata/  Also specify queryset and serializer for UpdateRecord.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_errata_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Filter results where id matches value
        :param str id__in: Filter results where id is in a comma-separated list of values
        :param str status: Filter results where status matches value
        :param str status__in: Filter results where status is in a comma-separated list of values
        :param str severity: Filter results where severity matches value
        :param str severity__in: Filter results where severity is in a comma-separated list of values
        :param str type: Filter results where type matches value
        :param str type__in: Filter results where type is in a comma-separated list of values
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_rpm_errata_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_rpm_errata_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_rpm_errata_list_with_http_info(self, **kwargs):  # noqa: E501
        """A ViewSet for UpdateRecord.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/errata/  Also specify queryset and serializer for UpdateRecord.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_errata_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: Filter results where id matches value
        :param str id__in: Filter results where id is in a comma-separated list of values
        :param str status: Filter results where status matches value
        :param str status__in: Filter results where status is in a comma-separated list of values
        :param str severity: Filter results where severity matches value
        :param str severity__in: Filter results where severity is in a comma-separated list of values
        :param str type: Filter results where type matches value
        :param str type__in: Filter results where type is in a comma-separated list of values
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'id__in', 'status', 'status__in', 'severity', 'severity__in', 'type', 'type__in', 'repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_rpm_errata_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'id__in' in params:
            query_params.append(('id__in', params['id__in']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'status__in' in params:
            query_params.append(('status__in', params['status__in']))  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
        if 'severity__in' in params:
            query_params.append(('severity__in', params['severity__in']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'type__in' in params:
            query_params.append(('type__in', params['type__in']))  # noqa: E501
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/rpm/errata/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_rpm_errata_read(self, update_record_href, **kwargs):  # noqa: E501
        """A ViewSet for UpdateRecord.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/errata/  Also specify queryset and serializer for UpdateRecord.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_errata_read(update_record_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str update_record_href: URI of Update Record. e.g.: /pulp/api/v3/content/rpm/errata/1/ (required)
        :return: UpdateRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_rpm_errata_read_with_http_info(update_record_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_rpm_errata_read_with_http_info(update_record_href, **kwargs)  # noqa: E501
            return data

    def content_rpm_errata_read_with_http_info(self, update_record_href, **kwargs):  # noqa: E501
        """A ViewSet for UpdateRecord.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/errata/  Also specify queryset and serializer for UpdateRecord.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_errata_read_with_http_info(update_record_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str update_record_href: URI of Update Record. e.g.: /pulp/api/v3/content/rpm/errata/1/ (required)
        :return: UpdateRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_record_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_rpm_errata_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_record_href' is set
        if ('update_record_href' not in params or
                params['update_record_href'] is None):
            raise ValueError("Missing the required parameter `update_record_href` when calling `content_rpm_errata_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'update_record_href' in params:
            path_params['update_record_href'] = params['update_record_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{update_record_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateRecord',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_rpm_packages_create(self, data, **kwargs):  # noqa: E501
        """content_rpm_packages_create  # noqa: E501

        Create a new Package from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_packages_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Package data: (required)
        :return: Package
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_rpm_packages_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.content_rpm_packages_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def content_rpm_packages_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """content_rpm_packages_create  # noqa: E501

        Create a new Package from a request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_packages_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Package data: (required)
        :return: Package
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_rpm_packages_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `content_rpm_packages_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/rpm/packages/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Package',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_rpm_packages_list(self, **kwargs):  # noqa: E501
        """A ViewSet for Package.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_packages_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Filter results where name matches value
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str epoch: Filter results where epoch matches value
        :param str epoch__in: Filter results where epoch is in a comma-separated list of values
        :param str version: Filter results where version matches value
        :param str version__in: Filter results where version is in a comma-separated list of values
        :param str release: Filter results where release matches value
        :param str release__in: Filter results where release is in a comma-separated list of values
        :param str arch: Filter results where arch matches value
        :param str arch__in: Filter results where arch is in a comma-separated list of values
        :param str pkg_id: Filter results where pkgId matches value
        :param str pkg_id__in: Filter results where pkgId is in a comma-separated list of values
        :param str checksum_type: Filter results where checksum_type matches value
        :param str checksum_type__in: Filter results where checksum_type is in a comma-separated list of values
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_rpm_packages_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.content_rpm_packages_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def content_rpm_packages_list_with_http_info(self, **kwargs):  # noqa: E501
        """A ViewSet for Package.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_packages_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: Filter results where name matches value
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str epoch: Filter results where epoch matches value
        :param str epoch__in: Filter results where epoch is in a comma-separated list of values
        :param str version: Filter results where version matches value
        :param str version__in: Filter results where version is in a comma-separated list of values
        :param str release: Filter results where release matches value
        :param str release__in: Filter results where release is in a comma-separated list of values
        :param str arch: Filter results where arch matches value
        :param str arch__in: Filter results where arch is in a comma-separated list of values
        :param str pkg_id: Filter results where pkgId matches value
        :param str pkg_id__in: Filter results where pkgId is in a comma-separated list of values
        :param str checksum_type: Filter results where checksum_type matches value
        :param str checksum_type__in: Filter results where checksum_type is in a comma-separated list of values
        :param str repository_version: Repository Version referenced by HREF
        :param str repository_version_added: Repository Version referenced by HREF
        :param str repository_version_removed: Repository Version referenced by HREF
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'epoch', 'epoch__in', 'version', 'version__in', 'release', 'release__in', 'arch', 'arch__in', 'pkg_id', 'pkg_id__in', 'checksum_type', 'checksum_type__in', 'repository_version', 'repository_version_added', 'repository_version_removed', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_rpm_packages_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'epoch' in params:
            query_params.append(('epoch', params['epoch']))  # noqa: E501
        if 'epoch__in' in params:
            query_params.append(('epoch__in', params['epoch__in']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'version__in' in params:
            query_params.append(('version__in', params['version__in']))  # noqa: E501
        if 'release' in params:
            query_params.append(('release', params['release']))  # noqa: E501
        if 'release__in' in params:
            query_params.append(('release__in', params['release__in']))  # noqa: E501
        if 'arch' in params:
            query_params.append(('arch', params['arch']))  # noqa: E501
        if 'arch__in' in params:
            query_params.append(('arch__in', params['arch__in']))  # noqa: E501
        if 'pkg_id' in params:
            query_params.append(('pkgId', params['pkg_id']))  # noqa: E501
        if 'pkg_id__in' in params:
            query_params.append(('pkgId__in', params['pkg_id__in']))  # noqa: E501
        if 'checksum_type' in params:
            query_params.append(('checksum_type', params['checksum_type']))  # noqa: E501
        if 'checksum_type__in' in params:
            query_params.append(('checksum_type__in', params['checksum_type__in']))  # noqa: E501
        if 'repository_version' in params:
            query_params.append(('repository_version', params['repository_version']))  # noqa: E501
        if 'repository_version_added' in params:
            query_params.append(('repository_version_added', params['repository_version_added']))  # noqa: E501
        if 'repository_version_removed' in params:
            query_params.append(('repository_version_removed', params['repository_version_removed']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/content/rpm/packages/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def content_rpm_packages_read(self, package_href, **kwargs):  # noqa: E501
        """A ViewSet for Package.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_packages_read(package_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str package_href: URI of Package. e.g.: /pulp/api/v3/content/rpm/packages/1/ (required)
        :return: Package
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.content_rpm_packages_read_with_http_info(package_href, **kwargs)  # noqa: E501
        else:
            (data) = self.content_rpm_packages_read_with_http_info(package_href, **kwargs)  # noqa: E501
            return data

    def content_rpm_packages_read_with_http_info(self, package_href, **kwargs):  # noqa: E501
        """A ViewSet for Package.  # noqa: E501

        Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.content_rpm_packages_read_with_http_info(package_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str package_href: URI of Package. e.g.: /pulp/api/v3/content/rpm/packages/1/ (required)
        :return: Package
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['package_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method content_rpm_packages_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'package_href' is set
        if ('package_href' not in params or
                params['package_href'] is None):
            raise ValueError("Missing the required parameter `package_href` when calling `content_rpm_packages_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'package_href' in params:
            path_params['package_href'] = params['package_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{package_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Package',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contentguards_certguard_certguard_create(self, data, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param CertGuard data: (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.contentguards_certguard_certguard_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.contentguards_certguard_certguard_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def contentguards_certguard_certguard_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param CertGuard data: (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contentguards_certguard_certguard_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `contentguards_certguard_certguard_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/contentguards/certguard/certguard/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertGuard',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contentguards_certguard_certguard_delete(self, cert_guard_href, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_delete(cert_guard_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.contentguards_certguard_certguard_delete_with_http_info(cert_guard_href, **kwargs)  # noqa: E501
        else:
            (data) = self.contentguards_certguard_certguard_delete_with_http_info(cert_guard_href, **kwargs)  # noqa: E501
            return data

    def contentguards_certguard_certguard_delete_with_http_info(self, cert_guard_href, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_delete_with_http_info(cert_guard_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_guard_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contentguards_certguard_certguard_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_guard_href' is set
        if ('cert_guard_href' not in params or
                params['cert_guard_href'] is None):
            raise ValueError("Missing the required parameter `cert_guard_href` when calling `contentguards_certguard_certguard_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cert_guard_href' in params:
            path_params['cert_guard_href'] = params['cert_guard_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{cert_guard_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contentguards_certguard_certguard_list(self, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.contentguards_certguard_certguard_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.contentguards_certguard_certguard_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def contentguards_certguard_certguard_list_with_http_info(self, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contentguards_certguard_certguard_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/contentguards/certguard/certguard/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contentguards_certguard_certguard_partial_update(self, cert_guard_href, data, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_partial_update(cert_guard_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :param CertGuard data: (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.contentguards_certguard_certguard_partial_update_with_http_info(cert_guard_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.contentguards_certguard_certguard_partial_update_with_http_info(cert_guard_href, data, **kwargs)  # noqa: E501
            return data

    def contentguards_certguard_certguard_partial_update_with_http_info(self, cert_guard_href, data, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_partial_update_with_http_info(cert_guard_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :param CertGuard data: (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_guard_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contentguards_certguard_certguard_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_guard_href' is set
        if ('cert_guard_href' not in params or
                params['cert_guard_href'] is None):
            raise ValueError("Missing the required parameter `cert_guard_href` when calling `contentguards_certguard_certguard_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `contentguards_certguard_certguard_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cert_guard_href' in params:
            path_params['cert_guard_href'] = params['cert_guard_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{cert_guard_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertGuard',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contentguards_certguard_certguard_read(self, cert_guard_href, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_read(cert_guard_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.contentguards_certguard_certguard_read_with_http_info(cert_guard_href, **kwargs)  # noqa: E501
        else:
            (data) = self.contentguards_certguard_certguard_read_with_http_info(cert_guard_href, **kwargs)  # noqa: E501
            return data

    def contentguards_certguard_certguard_read_with_http_info(self, cert_guard_href, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_read_with_http_info(cert_guard_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_guard_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contentguards_certguard_certguard_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_guard_href' is set
        if ('cert_guard_href' not in params or
                params['cert_guard_href'] is None):
            raise ValueError("Missing the required parameter `cert_guard_href` when calling `contentguards_certguard_certguard_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cert_guard_href' in params:
            path_params['cert_guard_href'] = params['cert_guard_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{cert_guard_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertGuard',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contentguards_certguard_certguard_update(self, cert_guard_href, data, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_update(cert_guard_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :param CertGuard data: (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.contentguards_certguard_certguard_update_with_http_info(cert_guard_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.contentguards_certguard_certguard_update_with_http_info(cert_guard_href, data, **kwargs)  # noqa: E501
            return data

    def contentguards_certguard_certguard_update_with_http_info(self, cert_guard_href, data, **kwargs):  # noqa: E501
        """contentguards_certguard_certguard_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.contentguards_certguard_certguard_update_with_http_info(cert_guard_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str cert_guard_href: URI of Cert Guard. e.g.: /pulp/api/v3/contentguards/certguard/certguard/1/ (required)
        :param CertGuard data: (required)
        :return: CertGuard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cert_guard_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contentguards_certguard_certguard_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cert_guard_href' is set
        if ('cert_guard_href' not in params or
                params['cert_guard_href'] is None):
            raise ValueError("Missing the required parameter `cert_guard_href` when calling `contentguards_certguard_certguard_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `contentguards_certguard_certguard_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cert_guard_href' in params:
            path_params['cert_guard_href'] = params['cert_guard_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{cert_guard_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CertGuard',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distributions_create(self, data, **kwargs):  # noqa: E501
        """distributions_create  # noqa: E501

        Trigger an asynchronous create task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Distribution data: (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distributions_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.distributions_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def distributions_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """distributions_create  # noqa: E501

        Trigger an asynchronous create task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Distribution data: (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributions_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `distributions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/distributions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Distribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distributions_delete(self, distribution_href, **kwargs):  # noqa: E501
        """distributions_delete  # noqa: E501

        Provides read and list methods and also provides asynchronous CUD methods to dispatch tasks with reservation that lock all Distributions preventing race conditions during base_path checking.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_delete(distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distributions_delete_with_http_info(distribution_href, **kwargs)  # noqa: E501
        else:
            (data) = self.distributions_delete_with_http_info(distribution_href, **kwargs)  # noqa: E501
            return data

    def distributions_delete_with_http_info(self, distribution_href, **kwargs):  # noqa: E501
        """distributions_delete  # noqa: E501

        Provides read and list methods and also provides asynchronous CUD methods to dispatch tasks with reservation that lock all Distributions preventing race conditions during base_path checking.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_delete_with_http_info(distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributions_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_href' is set
        if ('distribution_href' not in params or
                params['distribution_href'] is None):
            raise ValueError("Missing the required parameter `distribution_href` when calling `distributions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_href' in params:
            path_params['distribution_href'] = params['distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{distribution_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distributions_list(self, **kwargs):  # noqa: E501
        """distributions_list  # noqa: E501

        Provides read and list methods and also provides asynchronous CUD methods to dispatch tasks with reservation that lock all Distributions preventing race conditions during base_path checking.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str base_path: 
        :param str base_path__contains: Filter results where base_path contains value
        :param str base_path__icontains: Filter results where base_path contains value
        :param str base_path__in: Filter results where base_path is in a comma-separated list of values
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distributions_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.distributions_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def distributions_list_with_http_info(self, **kwargs):  # noqa: E501
        """distributions_list  # noqa: E501

        Provides read and list methods and also provides asynchronous CUD methods to dispatch tasks with reservation that lock all Distributions preventing race conditions during base_path checking.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str base_path: 
        :param str base_path__contains: Filter results where base_path contains value
        :param str base_path__icontains: Filter results where base_path contains value
        :param str base_path__in: Filter results where base_path is in a comma-separated list of values
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'base_path', 'base_path__contains', 'base_path__icontains', 'base_path__in', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributions_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'base_path' in params:
            query_params.append(('base_path', params['base_path']))  # noqa: E501
        if 'base_path__contains' in params:
            query_params.append(('base_path__contains', params['base_path__contains']))  # noqa: E501
        if 'base_path__icontains' in params:
            query_params.append(('base_path__icontains', params['base_path__icontains']))  # noqa: E501
        if 'base_path__in' in params:
            query_params.append(('base_path__in', params['base_path__in']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/distributions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distributions_partial_update(self, distribution_href, data, **kwargs):  # noqa: E501
        """distributions_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_partial_update(distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :param Distribution data: (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distributions_partial_update_with_http_info(distribution_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.distributions_partial_update_with_http_info(distribution_href, data, **kwargs)  # noqa: E501
            return data

    def distributions_partial_update_with_http_info(self, distribution_href, data, **kwargs):  # noqa: E501
        """distributions_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_partial_update_with_http_info(distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :param Distribution data: (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributions_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_href' is set
        if ('distribution_href' not in params or
                params['distribution_href'] is None):
            raise ValueError("Missing the required parameter `distribution_href` when calling `distributions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `distributions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_href' in params:
            path_params['distribution_href'] = params['distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{distribution_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Distribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distributions_read(self, distribution_href, **kwargs):  # noqa: E501
        """distributions_read  # noqa: E501

        Provides read and list methods and also provides asynchronous CUD methods to dispatch tasks with reservation that lock all Distributions preventing race conditions during base_path checking.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_read(distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distributions_read_with_http_info(distribution_href, **kwargs)  # noqa: E501
        else:
            (data) = self.distributions_read_with_http_info(distribution_href, **kwargs)  # noqa: E501
            return data

    def distributions_read_with_http_info(self, distribution_href, **kwargs):  # noqa: E501
        """distributions_read  # noqa: E501

        Provides read and list methods and also provides asynchronous CUD methods to dispatch tasks with reservation that lock all Distributions preventing race conditions during base_path checking.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_read_with_http_info(distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributions_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_href' is set
        if ('distribution_href' not in params or
                params['distribution_href'] is None):
            raise ValueError("Missing the required parameter `distribution_href` when calling `distributions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_href' in params:
            path_params['distribution_href'] = params['distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{distribution_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Distribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distributions_update(self, distribution_href, data, **kwargs):  # noqa: E501
        """distributions_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_update(distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :param Distribution data: (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.distributions_update_with_http_info(distribution_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.distributions_update_with_http_info(distribution_href, data, **kwargs)  # noqa: E501
            return data

    def distributions_update_with_http_info(self, distribution_href, data, **kwargs):  # noqa: E501
        """distributions_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.distributions_update_with_http_info(distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str distribution_href: URI of Distribution. e.g.: /pulp/api/v3/distributions/1/ (required)
        :param Distribution data: (required)
        :return: Distribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributions_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_href' is set
        if ('distribution_href' not in params or
                params['distribution_href'] is None):
            raise ValueError("Missing the required parameter `distribution_href` when calling `distributions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `distributions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_href' in params:
            path_params['distribution_href'] = params['distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{distribution_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Distribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def docker_distributions_create(self, data, **kwargs):  # noqa: E501
        """docker_distributions_create  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param DockerDistribution data: (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.docker_distributions_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.docker_distributions_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def docker_distributions_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """docker_distributions_create  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param DockerDistribution data: (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method docker_distributions_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `docker_distributions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/docker-distributions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerDistribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def docker_distributions_delete(self, docker_distribution_href, **kwargs):  # noqa: E501
        """docker_distributions_delete  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_delete(docker_distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.docker_distributions_delete_with_http_info(docker_distribution_href, **kwargs)  # noqa: E501
        else:
            (data) = self.docker_distributions_delete_with_http_info(docker_distribution_href, **kwargs)  # noqa: E501
            return data

    def docker_distributions_delete_with_http_info(self, docker_distribution_href, **kwargs):  # noqa: E501
        """docker_distributions_delete  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_delete_with_http_info(docker_distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_distribution_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method docker_distributions_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_distribution_href' is set
        if ('docker_distribution_href' not in params or
                params['docker_distribution_href'] is None):
            raise ValueError("Missing the required parameter `docker_distribution_href` when calling `docker_distributions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_distribution_href' in params:
            path_params['docker_distribution_href'] = params['docker_distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_distribution_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def docker_distributions_list(self, **kwargs):  # noqa: E501
        """docker_distributions_list  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.docker_distributions_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.docker_distributions_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def docker_distributions_list_with_http_info(self, **kwargs):  # noqa: E501
        """docker_distributions_list  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method docker_distributions_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/docker-distributions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def docker_distributions_partial_update(self, docker_distribution_href, data, **kwargs):  # noqa: E501
        """docker_distributions_partial_update  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_partial_update(docker_distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :param DockerDistribution data: (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.docker_distributions_partial_update_with_http_info(docker_distribution_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.docker_distributions_partial_update_with_http_info(docker_distribution_href, data, **kwargs)  # noqa: E501
            return data

    def docker_distributions_partial_update_with_http_info(self, docker_distribution_href, data, **kwargs):  # noqa: E501
        """docker_distributions_partial_update  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_partial_update_with_http_info(docker_distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :param DockerDistribution data: (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_distribution_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method docker_distributions_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_distribution_href' is set
        if ('docker_distribution_href' not in params or
                params['docker_distribution_href'] is None):
            raise ValueError("Missing the required parameter `docker_distribution_href` when calling `docker_distributions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `docker_distributions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_distribution_href' in params:
            path_params['docker_distribution_href'] = params['docker_distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_distribution_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerDistribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def docker_distributions_read(self, docker_distribution_href, **kwargs):  # noqa: E501
        """docker_distributions_read  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_read(docker_distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.docker_distributions_read_with_http_info(docker_distribution_href, **kwargs)  # noqa: E501
        else:
            (data) = self.docker_distributions_read_with_http_info(docker_distribution_href, **kwargs)  # noqa: E501
            return data

    def docker_distributions_read_with_http_info(self, docker_distribution_href, **kwargs):  # noqa: E501
        """docker_distributions_read  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_read_with_http_info(docker_distribution_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_distribution_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method docker_distributions_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_distribution_href' is set
        if ('docker_distribution_href' not in params or
                params['docker_distribution_href'] is None):
            raise ValueError("Missing the required parameter `docker_distribution_href` when calling `docker_distributions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_distribution_href' in params:
            path_params['docker_distribution_href'] = params['docker_distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_distribution_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerDistribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def docker_distributions_update(self, docker_distribution_href, data, **kwargs):  # noqa: E501
        """docker_distributions_update  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_update(docker_distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :param DockerDistribution data: (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.docker_distributions_update_with_http_info(docker_distribution_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.docker_distributions_update_with_http_info(docker_distribution_href, data, **kwargs)  # noqa: E501
            return data

    def docker_distributions_update_with_http_info(self, docker_distribution_href, data, **kwargs):  # noqa: E501
        """docker_distributions_update  # noqa: E501

        ViewSet for DockerDistribution model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.docker_distributions_update_with_http_info(docker_distribution_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_distribution_href: URI of Docker Distribution. e.g.: /pulp/api/v3/docker-distributions/1/ (required)
        :param DockerDistribution data: (required)
        :return: DockerDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_distribution_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method docker_distributions_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_distribution_href' is set
        if ('docker_distribution_href' not in params or
                params['docker_distribution_href'] is None):
            raise ValueError("Missing the required parameter `docker_distribution_href` when calling `docker_distributions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `docker_distributions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_distribution_href' in params:
            path_params['docker_distribution_href'] = params['docker_distribution_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_distribution_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerDistribution',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def orphans_delete(self, **kwargs):  # noqa: E501
        """orphans_delete  # noqa: E501

        Cleans up all the Content and Artifact orphans in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.orphans_delete(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.orphans_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.orphans_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def orphans_delete_with_http_info(self, **kwargs):  # noqa: E501
        """orphans_delete  # noqa: E501

        Cleans up all the Content and Artifact orphans in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.orphans_delete_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method orphans_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/orphans/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publications_delete(self, publication_href, **kwargs):  # noqa: E501
        """publications_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publications_delete(publication_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str publication_href: URI of Publication. e.g.: /pulp/api/v3/publications/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publications_delete_with_http_info(publication_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publications_delete_with_http_info(publication_href, **kwargs)  # noqa: E501
            return data

    def publications_delete_with_http_info(self, publication_href, **kwargs):  # noqa: E501
        """publications_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publications_delete_with_http_info(publication_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str publication_href: URI of Publication. e.g.: /pulp/api/v3/publications/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['publication_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publications_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'publication_href' is set
        if ('publication_href' not in params or
                params['publication_href'] is None):
            raise ValueError("Missing the required parameter `publication_href` when calling `publications_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'publication_href' in params:
            path_params['publication_href'] = params['publication_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{publication_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publications_list(self, **kwargs):  # noqa: E501
        """publications_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publications_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str ordering: Which field to use when ordering the results.
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publications_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.publications_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def publications_list_with_http_info(self, **kwargs):  # noqa: E501
        """publications_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publications_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str ordering: Which field to use when ordering the results.
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ordering', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publications_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publications/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publications_read(self, publication_href, **kwargs):  # noqa: E501
        """publications_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publications_read(publication_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str publication_href: URI of Publication. e.g.: /pulp/api/v3/publications/1/ (required)
        :return: Publication
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publications_read_with_http_info(publication_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publications_read_with_http_info(publication_href, **kwargs)  # noqa: E501
            return data

    def publications_read_with_http_info(self, publication_href, **kwargs):  # noqa: E501
        """publications_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publications_read_with_http_info(publication_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str publication_href: URI of Publication. e.g.: /pulp/api/v3/publications/1/ (required)
        :return: Publication
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['publication_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publications_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'publication_href' is set
        if ('publication_href' not in params or
                params['publication_href'] is None):
            raise ValueError("Missing the required parameter `publication_href` when calling `publications_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'publication_href' in params:
            path_params['publication_href'] = params['publication_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{publication_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Publication',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_create(self, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_create  # noqa: E501

        A ViewSet for DockerPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param DockerPublisher data: (required)
        :return: DockerPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_create  # noqa: E501

        A ViewSet for DockerPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param DockerPublisher data: (required)
        :return: DockerPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_docker_docker_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publishers/docker/docker/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerPublisher',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_delete(self, docker_publisher_href, **kwargs):  # noqa: E501
        """publishers_docker_docker_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_delete(docker_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_delete_with_http_info(docker_publisher_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_delete_with_http_info(docker_publisher_href, **kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_delete_with_http_info(self, docker_publisher_href, **kwargs):  # noqa: E501
        """publishers_docker_docker_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_delete_with_http_info(docker_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_publisher_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_publisher_href' is set
        if ('docker_publisher_href' not in params or
                params['docker_publisher_href'] is None):
            raise ValueError("Missing the required parameter `docker_publisher_href` when calling `publishers_docker_docker_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_publisher_href' in params:
            path_params['docker_publisher_href'] = params['docker_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_publisher_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_list(self, **kwargs):  # noqa: E501
        """publishers_docker_docker_list  # noqa: E501

        A ViewSet for DockerPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_list_with_http_info(self, **kwargs):  # noqa: E501
        """publishers_docker_docker_list  # noqa: E501

        A ViewSet for DockerPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_updated__lt', 'last_updated__lte', 'last_updated__gt', 'last_updated__gte', 'last_updated__range', 'last_updated', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_updated__lt' in params:
            query_params.append(('_last_updated__lt', params['last_updated__lt']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('_last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'last_updated__gt' in params:
            query_params.append(('_last_updated__gt', params['last_updated__gt']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('_last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__range' in params:
            query_params.append(('_last_updated__range', params['last_updated__range']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('_last_updated', params['last_updated']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publishers/docker/docker/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_partial_update(self, docker_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_partial_update(docker_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :param DockerPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_partial_update_with_http_info(docker_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_partial_update_with_http_info(docker_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_partial_update_with_http_info(self, docker_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_partial_update_with_http_info(docker_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :param DockerPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_publisher_href' is set
        if ('docker_publisher_href' not in params or
                params['docker_publisher_href'] is None):
            raise ValueError("Missing the required parameter `docker_publisher_href` when calling `publishers_docker_docker_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_docker_docker_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_publisher_href' in params:
            path_params['docker_publisher_href'] = params['docker_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_publisher_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_publish(self, docker_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_publish  # noqa: E501

        Trigger an asynchronous task to publish content  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_publish(docker_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :param RepositoryPublishURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_publish_with_http_info(docker_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_publish_with_http_info(docker_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_publish_with_http_info(self, docker_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_publish  # noqa: E501

        Trigger an asynchronous task to publish content  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_publish_with_http_info(docker_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :param RepositoryPublishURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_publish" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_publisher_href' is set
        if ('docker_publisher_href' not in params or
                params['docker_publisher_href'] is None):
            raise ValueError("Missing the required parameter `docker_publisher_href` when calling `publishers_docker_docker_publish`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_docker_docker_publish`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_publisher_href' in params:
            path_params['docker_publisher_href'] = params['docker_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_publisher_href}publish/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_read(self, docker_publisher_href, **kwargs):  # noqa: E501
        """publishers_docker_docker_read  # noqa: E501

        A ViewSet for DockerPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_read(docker_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :return: DockerPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_read_with_http_info(docker_publisher_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_read_with_http_info(docker_publisher_href, **kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_read_with_http_info(self, docker_publisher_href, **kwargs):  # noqa: E501
        """publishers_docker_docker_read  # noqa: E501

        A ViewSet for DockerPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_read_with_http_info(docker_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :return: DockerPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_publisher_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_publisher_href' is set
        if ('docker_publisher_href' not in params or
                params['docker_publisher_href'] is None):
            raise ValueError("Missing the required parameter `docker_publisher_href` when calling `publishers_docker_docker_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_publisher_href' in params:
            path_params['docker_publisher_href'] = params['docker_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_publisher_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerPublisher',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_docker_docker_update(self, docker_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_update(docker_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :param DockerPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_docker_docker_update_with_http_info(docker_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_docker_docker_update_with_http_info(docker_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_docker_docker_update_with_http_info(self, docker_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_docker_docker_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_docker_docker_update_with_http_info(docker_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_publisher_href: URI of Docker Publisher. e.g.: /pulp/api/v3/publishers/docker/docker/1/ (required)
        :param DockerPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_docker_docker_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_publisher_href' is set
        if ('docker_publisher_href' not in params or
                params['docker_publisher_href'] is None):
            raise ValueError("Missing the required parameter `docker_publisher_href` when calling `publishers_docker_docker_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_docker_docker_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_publisher_href' in params:
            path_params['docker_publisher_href'] = params['docker_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_publisher_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_create(self, data, **kwargs):  # noqa: E501
        """publishers_file_file_create  # noqa: E501

        ViewSet for File Publishers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param FilePublisher data: (required)
        :return: FilePublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def publishers_file_file_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """publishers_file_file_create  # noqa: E501

        ViewSet for File Publishers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param FilePublisher data: (required)
        :return: FilePublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_file_file_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publishers/file/file/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilePublisher',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_delete(self, file_publisher_href, **kwargs):  # noqa: E501
        """publishers_file_file_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_delete(file_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_delete_with_http_info(file_publisher_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_delete_with_http_info(file_publisher_href, **kwargs)  # noqa: E501
            return data

    def publishers_file_file_delete_with_http_info(self, file_publisher_href, **kwargs):  # noqa: E501
        """publishers_file_file_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_delete_with_http_info(file_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_publisher_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_publisher_href' is set
        if ('file_publisher_href' not in params or
                params['file_publisher_href'] is None):
            raise ValueError("Missing the required parameter `file_publisher_href` when calling `publishers_file_file_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_publisher_href' in params:
            path_params['file_publisher_href'] = params['file_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_publisher_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_list(self, **kwargs):  # noqa: E501
        """publishers_file_file_list  # noqa: E501

        ViewSet for File Publishers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def publishers_file_file_list_with_http_info(self, **kwargs):  # noqa: E501
        """publishers_file_file_list  # noqa: E501

        ViewSet for File Publishers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_updated__lt', 'last_updated__lte', 'last_updated__gt', 'last_updated__gte', 'last_updated__range', 'last_updated', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_updated__lt' in params:
            query_params.append(('_last_updated__lt', params['last_updated__lt']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('_last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'last_updated__gt' in params:
            query_params.append(('_last_updated__gt', params['last_updated__gt']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('_last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__range' in params:
            query_params.append(('_last_updated__range', params['last_updated__range']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('_last_updated', params['last_updated']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publishers/file/file/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_partial_update(self, file_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_file_file_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_partial_update(file_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :param FilePublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_partial_update_with_http_info(file_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_partial_update_with_http_info(file_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_file_file_partial_update_with_http_info(self, file_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_file_file_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_partial_update_with_http_info(file_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :param FilePublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_publisher_href' is set
        if ('file_publisher_href' not in params or
                params['file_publisher_href'] is None):
            raise ValueError("Missing the required parameter `file_publisher_href` when calling `publishers_file_file_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_file_file_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_publisher_href' in params:
            path_params['file_publisher_href'] = params['file_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_publisher_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_publish(self, file_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_file_file_publish  # noqa: E501

        Trigger an asynchronous task to publish file content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_publish(file_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :param RepositoryPublishURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_publish_with_http_info(file_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_publish_with_http_info(file_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_file_file_publish_with_http_info(self, file_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_file_file_publish  # noqa: E501

        Trigger an asynchronous task to publish file content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_publish_with_http_info(file_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :param RepositoryPublishURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_publish" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_publisher_href' is set
        if ('file_publisher_href' not in params or
                params['file_publisher_href'] is None):
            raise ValueError("Missing the required parameter `file_publisher_href` when calling `publishers_file_file_publish`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_file_file_publish`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_publisher_href' in params:
            path_params['file_publisher_href'] = params['file_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_publisher_href}publish/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_read(self, file_publisher_href, **kwargs):  # noqa: E501
        """publishers_file_file_read  # noqa: E501

        ViewSet for File Publishers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_read(file_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :return: FilePublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_read_with_http_info(file_publisher_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_read_with_http_info(file_publisher_href, **kwargs)  # noqa: E501
            return data

    def publishers_file_file_read_with_http_info(self, file_publisher_href, **kwargs):  # noqa: E501
        """publishers_file_file_read  # noqa: E501

        ViewSet for File Publishers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_read_with_http_info(file_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :return: FilePublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_publisher_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_publisher_href' is set
        if ('file_publisher_href' not in params or
                params['file_publisher_href'] is None):
            raise ValueError("Missing the required parameter `file_publisher_href` when calling `publishers_file_file_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_publisher_href' in params:
            path_params['file_publisher_href'] = params['file_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_publisher_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FilePublisher',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_file_file_update(self, file_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_file_file_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_update(file_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :param FilePublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_file_file_update_with_http_info(file_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_file_file_update_with_http_info(file_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_file_file_update_with_http_info(self, file_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_file_file_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_file_file_update_with_http_info(file_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_publisher_href: URI of File Publisher. e.g.: /pulp/api/v3/publishers/file/file/1/ (required)
        :param FilePublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_file_file_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_publisher_href' is set
        if ('file_publisher_href' not in params or
                params['file_publisher_href'] is None):
            raise ValueError("Missing the required parameter `file_publisher_href` when calling `publishers_file_file_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_file_file_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_publisher_href' in params:
            path_params['file_publisher_href'] = params['file_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_publisher_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_create(self, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_create  # noqa: E501

        A ViewSet for RpmPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param RpmPublisher data: (required)
        :return: RpmPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_create  # noqa: E501

        A ViewSet for RpmPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param RpmPublisher data: (required)
        :return: RpmPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_rpm_rpm_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publishers/rpm/rpm/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RpmPublisher',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_delete(self, rpm_publisher_href, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_delete(rpm_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_delete_with_http_info(rpm_publisher_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_delete_with_http_info(rpm_publisher_href, **kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_delete_with_http_info(self, rpm_publisher_href, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_delete_with_http_info(rpm_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_publisher_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_publisher_href' is set
        if ('rpm_publisher_href' not in params or
                params['rpm_publisher_href'] is None):
            raise ValueError("Missing the required parameter `rpm_publisher_href` when calling `publishers_rpm_rpm_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_publisher_href' in params:
            path_params['rpm_publisher_href'] = params['rpm_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_publisher_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_list(self, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_list  # noqa: E501

        A ViewSet for RpmPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_list_with_http_info(self, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_list  # noqa: E501

        A ViewSet for RpmPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_updated__lt', 'last_updated__lte', 'last_updated__gt', 'last_updated__gte', 'last_updated__range', 'last_updated', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_updated__lt' in params:
            query_params.append(('_last_updated__lt', params['last_updated__lt']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('_last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'last_updated__gt' in params:
            query_params.append(('_last_updated__gt', params['last_updated__gt']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('_last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__range' in params:
            query_params.append(('_last_updated__range', params['last_updated__range']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('_last_updated', params['last_updated']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/publishers/rpm/rpm/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_partial_update(self, rpm_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_partial_update(rpm_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :param RpmPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_partial_update_with_http_info(rpm_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_partial_update_with_http_info(rpm_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_partial_update_with_http_info(self, rpm_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_partial_update_with_http_info(rpm_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :param RpmPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_publisher_href' is set
        if ('rpm_publisher_href' not in params or
                params['rpm_publisher_href'] is None):
            raise ValueError("Missing the required parameter `rpm_publisher_href` when calling `publishers_rpm_rpm_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_rpm_rpm_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_publisher_href' in params:
            path_params['rpm_publisher_href'] = params['rpm_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_publisher_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_publish(self, rpm_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_publish  # noqa: E501

        Trigger an asynchronous task to publish RPM content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_publish(rpm_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :param RepositoryPublishURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_publish_with_http_info(rpm_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_publish_with_http_info(rpm_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_publish_with_http_info(self, rpm_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_publish  # noqa: E501

        Trigger an asynchronous task to publish RPM content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_publish_with_http_info(rpm_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :param RepositoryPublishURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_publish" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_publisher_href' is set
        if ('rpm_publisher_href' not in params or
                params['rpm_publisher_href'] is None):
            raise ValueError("Missing the required parameter `rpm_publisher_href` when calling `publishers_rpm_rpm_publish`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_rpm_rpm_publish`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_publisher_href' in params:
            path_params['rpm_publisher_href'] = params['rpm_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_publisher_href}publish/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_read(self, rpm_publisher_href, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_read  # noqa: E501

        A ViewSet for RpmPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_read(rpm_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :return: RpmPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_read_with_http_info(rpm_publisher_href, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_read_with_http_info(rpm_publisher_href, **kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_read_with_http_info(self, rpm_publisher_href, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_read  # noqa: E501

        A ViewSet for RpmPublisher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_read_with_http_info(rpm_publisher_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :return: RpmPublisher
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_publisher_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_publisher_href' is set
        if ('rpm_publisher_href' not in params or
                params['rpm_publisher_href'] is None):
            raise ValueError("Missing the required parameter `rpm_publisher_href` when calling `publishers_rpm_rpm_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_publisher_href' in params:
            path_params['rpm_publisher_href'] = params['rpm_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_publisher_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RpmPublisher',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publishers_rpm_rpm_update(self, rpm_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_update(rpm_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :param RpmPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.publishers_rpm_rpm_update_with_http_info(rpm_publisher_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.publishers_rpm_rpm_update_with_http_info(rpm_publisher_href, data, **kwargs)  # noqa: E501
            return data

    def publishers_rpm_rpm_update_with_http_info(self, rpm_publisher_href, data, **kwargs):  # noqa: E501
        """publishers_rpm_rpm_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.publishers_rpm_rpm_update_with_http_info(rpm_publisher_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_publisher_href: URI of Rpm Publisher. e.g.: /pulp/api/v3/publishers/rpm/rpm/1/ (required)
        :param RpmPublisher data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_publisher_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publishers_rpm_rpm_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_publisher_href' is set
        if ('rpm_publisher_href' not in params or
                params['rpm_publisher_href'] is None):
            raise ValueError("Missing the required parameter `rpm_publisher_href` when calling `publishers_rpm_rpm_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `publishers_rpm_rpm_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_publisher_href' in params:
            path_params['rpm_publisher_href'] = params['rpm_publisher_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_publisher_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_create(self, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_create  # noqa: E501

        A ViewSet for DockerRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param DockerRemote data: (required)
        :return: DockerRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_create  # noqa: E501

        A ViewSet for DockerRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param DockerRemote data: (required)
        :return: DockerRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_docker_docker_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/remotes/docker/docker/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerRemote',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_delete(self, docker_remote_href, **kwargs):  # noqa: E501
        """remotes_docker_docker_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_delete(docker_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_delete_with_http_info(docker_remote_href, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_delete_with_http_info(docker_remote_href, **kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_delete_with_http_info(self, docker_remote_href, **kwargs):  # noqa: E501
        """remotes_docker_docker_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_delete_with_http_info(docker_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_remote_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_remote_href' is set
        if ('docker_remote_href' not in params or
                params['docker_remote_href'] is None):
            raise ValueError("Missing the required parameter `docker_remote_href` when calling `remotes_docker_docker_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_remote_href' in params:
            path_params['docker_remote_href'] = params['docker_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_remote_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_list(self, **kwargs):  # noqa: E501
        """remotes_docker_docker_list  # noqa: E501

        A ViewSet for DockerRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_list_with_http_info(self, **kwargs):  # noqa: E501
        """remotes_docker_docker_list  # noqa: E501

        A ViewSet for DockerRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_updated__lt', 'last_updated__lte', 'last_updated__gt', 'last_updated__gte', 'last_updated__range', 'last_updated', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_updated__lt' in params:
            query_params.append(('_last_updated__lt', params['last_updated__lt']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('_last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'last_updated__gt' in params:
            query_params.append(('_last_updated__gt', params['last_updated__gt']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('_last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__range' in params:
            query_params.append(('_last_updated__range', params['last_updated__range']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('_last_updated', params['last_updated']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/remotes/docker/docker/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_partial_update(self, docker_remote_href, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_partial_update(docker_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :param DockerRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_partial_update_with_http_info(docker_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_partial_update_with_http_info(docker_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_partial_update_with_http_info(self, docker_remote_href, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_partial_update_with_http_info(docker_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :param DockerRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_remote_href' is set
        if ('docker_remote_href' not in params or
                params['docker_remote_href'] is None):
            raise ValueError("Missing the required parameter `docker_remote_href` when calling `remotes_docker_docker_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_docker_docker_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_remote_href' in params:
            path_params['docker_remote_href'] = params['docker_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_remote_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_read(self, docker_remote_href, **kwargs):  # noqa: E501
        """remotes_docker_docker_read  # noqa: E501

        A ViewSet for DockerRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_read(docker_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :return: DockerRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_read_with_http_info(docker_remote_href, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_read_with_http_info(docker_remote_href, **kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_read_with_http_info(self, docker_remote_href, **kwargs):  # noqa: E501
        """remotes_docker_docker_read  # noqa: E501

        A ViewSet for DockerRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_read_with_http_info(docker_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :return: DockerRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_remote_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_remote_href' is set
        if ('docker_remote_href' not in params or
                params['docker_remote_href'] is None):
            raise ValueError("Missing the required parameter `docker_remote_href` when calling `remotes_docker_docker_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_remote_href' in params:
            path_params['docker_remote_href'] = params['docker_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_remote_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerRemote',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_sync(self, docker_remote_href, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_sync  # noqa: E501

        Trigger an asynchronous task to sync content  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_sync(docker_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :param RepositorySyncURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_sync_with_http_info(docker_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_sync_with_http_info(docker_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_sync_with_http_info(self, docker_remote_href, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_sync  # noqa: E501

        Trigger an asynchronous task to sync content  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_sync_with_http_info(docker_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :param RepositorySyncURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_sync" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_remote_href' is set
        if ('docker_remote_href' not in params or
                params['docker_remote_href'] is None):
            raise ValueError("Missing the required parameter `docker_remote_href` when calling `remotes_docker_docker_sync`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_docker_docker_sync`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_remote_href' in params:
            path_params['docker_remote_href'] = params['docker_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_remote_href}sync/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_docker_docker_update(self, docker_remote_href, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_update(docker_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :param DockerRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_docker_docker_update_with_http_info(docker_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_docker_docker_update_with_http_info(docker_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_docker_docker_update_with_http_info(self, docker_remote_href, data, **kwargs):  # noqa: E501
        """remotes_docker_docker_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_docker_docker_update_with_http_info(docker_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str docker_remote_href: URI of Docker Remote. e.g.: /pulp/api/v3/remotes/docker/docker/1/ (required)
        :param DockerRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docker_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_docker_docker_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docker_remote_href' is set
        if ('docker_remote_href' not in params or
                params['docker_remote_href'] is None):
            raise ValueError("Missing the required parameter `docker_remote_href` when calling `remotes_docker_docker_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_docker_docker_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'docker_remote_href' in params:
            path_params['docker_remote_href'] = params['docker_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{docker_remote_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_create(self, data, **kwargs):  # noqa: E501
        """remotes_file_file_create  # noqa: E501

        ViewSet for File Remotes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param FileRemote data: (required)
        :return: FileRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def remotes_file_file_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """remotes_file_file_create  # noqa: E501

        ViewSet for File Remotes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param FileRemote data: (required)
        :return: FileRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_file_file_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/remotes/file/file/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileRemote',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_delete(self, file_remote_href, **kwargs):  # noqa: E501
        """remotes_file_file_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_delete(file_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_delete_with_http_info(file_remote_href, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_delete_with_http_info(file_remote_href, **kwargs)  # noqa: E501
            return data

    def remotes_file_file_delete_with_http_info(self, file_remote_href, **kwargs):  # noqa: E501
        """remotes_file_file_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_delete_with_http_info(file_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_remote_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_remote_href' is set
        if ('file_remote_href' not in params or
                params['file_remote_href'] is None):
            raise ValueError("Missing the required parameter `file_remote_href` when calling `remotes_file_file_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_remote_href' in params:
            path_params['file_remote_href'] = params['file_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_remote_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_list(self, **kwargs):  # noqa: E501
        """remotes_file_file_list  # noqa: E501

        ViewSet for File Remotes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def remotes_file_file_list_with_http_info(self, **kwargs):  # noqa: E501
        """remotes_file_file_list  # noqa: E501

        ViewSet for File Remotes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_updated__lt', 'last_updated__lte', 'last_updated__gt', 'last_updated__gte', 'last_updated__range', 'last_updated', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_updated__lt' in params:
            query_params.append(('_last_updated__lt', params['last_updated__lt']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('_last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'last_updated__gt' in params:
            query_params.append(('_last_updated__gt', params['last_updated__gt']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('_last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__range' in params:
            query_params.append(('_last_updated__range', params['last_updated__range']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('_last_updated', params['last_updated']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/remotes/file/file/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_partial_update(self, file_remote_href, data, **kwargs):  # noqa: E501
        """remotes_file_file_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_partial_update(file_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :param FileRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_partial_update_with_http_info(file_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_partial_update_with_http_info(file_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_file_file_partial_update_with_http_info(self, file_remote_href, data, **kwargs):  # noqa: E501
        """remotes_file_file_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_partial_update_with_http_info(file_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :param FileRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_remote_href' is set
        if ('file_remote_href' not in params or
                params['file_remote_href'] is None):
            raise ValueError("Missing the required parameter `file_remote_href` when calling `remotes_file_file_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_file_file_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_remote_href' in params:
            path_params['file_remote_href'] = params['file_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_remote_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_read(self, file_remote_href, **kwargs):  # noqa: E501
        """remotes_file_file_read  # noqa: E501

        ViewSet for File Remotes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_read(file_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :return: FileRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_read_with_http_info(file_remote_href, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_read_with_http_info(file_remote_href, **kwargs)  # noqa: E501
            return data

    def remotes_file_file_read_with_http_info(self, file_remote_href, **kwargs):  # noqa: E501
        """remotes_file_file_read  # noqa: E501

        ViewSet for File Remotes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_read_with_http_info(file_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :return: FileRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_remote_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_remote_href' is set
        if ('file_remote_href' not in params or
                params['file_remote_href'] is None):
            raise ValueError("Missing the required parameter `file_remote_href` when calling `remotes_file_file_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_remote_href' in params:
            path_params['file_remote_href'] = params['file_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_remote_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileRemote',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_sync(self, file_remote_href, data, **kwargs):  # noqa: E501
        """remotes_file_file_sync  # noqa: E501

        Trigger an asynchronous task to sync file content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_sync(file_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :param RepositorySyncURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_sync_with_http_info(file_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_sync_with_http_info(file_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_file_file_sync_with_http_info(self, file_remote_href, data, **kwargs):  # noqa: E501
        """remotes_file_file_sync  # noqa: E501

        Trigger an asynchronous task to sync file content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_sync_with_http_info(file_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :param RepositorySyncURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_sync" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_remote_href' is set
        if ('file_remote_href' not in params or
                params['file_remote_href'] is None):
            raise ValueError("Missing the required parameter `file_remote_href` when calling `remotes_file_file_sync`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_file_file_sync`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_remote_href' in params:
            path_params['file_remote_href'] = params['file_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_remote_href}sync/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_file_file_update(self, file_remote_href, data, **kwargs):  # noqa: E501
        """remotes_file_file_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_update(file_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :param FileRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_file_file_update_with_http_info(file_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_file_file_update_with_http_info(file_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_file_file_update_with_http_info(self, file_remote_href, data, **kwargs):  # noqa: E501
        """remotes_file_file_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_file_file_update_with_http_info(file_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str file_remote_href: URI of File Remote. e.g.: /pulp/api/v3/remotes/file/file/1/ (required)
        :param FileRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_file_file_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_remote_href' is set
        if ('file_remote_href' not in params or
                params['file_remote_href'] is None):
            raise ValueError("Missing the required parameter `file_remote_href` when calling `remotes_file_file_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_file_file_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_remote_href' in params:
            path_params['file_remote_href'] = params['file_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{file_remote_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_create(self, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_create  # noqa: E501

        A ViewSet for RpmRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param RpmRemote data: (required)
        :return: RpmRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_create  # noqa: E501

        A ViewSet for RpmRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param RpmRemote data: (required)
        :return: RpmRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_rpm_rpm_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/remotes/rpm/rpm/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RpmRemote',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_delete(self, rpm_remote_href, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_delete(rpm_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_delete_with_http_info(rpm_remote_href, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_delete_with_http_info(rpm_remote_href, **kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_delete_with_http_info(self, rpm_remote_href, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_delete  # noqa: E501

        Trigger an asynchronous delete task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_delete_with_http_info(rpm_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_remote_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_remote_href' is set
        if ('rpm_remote_href' not in params or
                params['rpm_remote_href'] is None):
            raise ValueError("Missing the required parameter `rpm_remote_href` when calling `remotes_rpm_rpm_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_remote_href' in params:
            path_params['rpm_remote_href'] = params['rpm_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_remote_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_list(self, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_list  # noqa: E501

        A ViewSet for RpmRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_list_with_http_info(self, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_list  # noqa: E501

        A ViewSet for RpmRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_updated__lt: Filter results where _last_updated is less than value
        :param str last_updated__lte: Filter results where _last_updated is less than or equal to value
        :param str last_updated__gt: Filter results where _last_updated is greater than value
        :param str last_updated__gte: Filter results where _last_updated is greater than or equal to value
        :param str last_updated__range: Filter results where _last_updated is between two comma separated values
        :param str last_updated: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_updated__lt', 'last_updated__lte', 'last_updated__gt', 'last_updated__gte', 'last_updated__range', 'last_updated', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_updated__lt' in params:
            query_params.append(('_last_updated__lt', params['last_updated__lt']))  # noqa: E501
        if 'last_updated__lte' in params:
            query_params.append(('_last_updated__lte', params['last_updated__lte']))  # noqa: E501
        if 'last_updated__gt' in params:
            query_params.append(('_last_updated__gt', params['last_updated__gt']))  # noqa: E501
        if 'last_updated__gte' in params:
            query_params.append(('_last_updated__gte', params['last_updated__gte']))  # noqa: E501
        if 'last_updated__range' in params:
            query_params.append(('_last_updated__range', params['last_updated__range']))  # noqa: E501
        if 'last_updated' in params:
            query_params.append(('_last_updated', params['last_updated']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/remotes/rpm/rpm/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_partial_update(self, rpm_remote_href, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_partial_update(rpm_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :param RpmRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_partial_update_with_http_info(rpm_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_partial_update_with_http_info(rpm_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_partial_update_with_http_info(self, rpm_remote_href, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_partial_update  # noqa: E501

        Trigger an asynchronous partial update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_partial_update_with_http_info(rpm_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :param RpmRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_remote_href' is set
        if ('rpm_remote_href' not in params or
                params['rpm_remote_href'] is None):
            raise ValueError("Missing the required parameter `rpm_remote_href` when calling `remotes_rpm_rpm_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_rpm_rpm_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_remote_href' in params:
            path_params['rpm_remote_href'] = params['rpm_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_remote_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_read(self, rpm_remote_href, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_read  # noqa: E501

        A ViewSet for RpmRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_read(rpm_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :return: RpmRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_read_with_http_info(rpm_remote_href, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_read_with_http_info(rpm_remote_href, **kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_read_with_http_info(self, rpm_remote_href, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_read  # noqa: E501

        A ViewSet for RpmRemote.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_read_with_http_info(rpm_remote_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :return: RpmRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_remote_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_remote_href' is set
        if ('rpm_remote_href' not in params or
                params['rpm_remote_href'] is None):
            raise ValueError("Missing the required parameter `rpm_remote_href` when calling `remotes_rpm_rpm_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_remote_href' in params:
            path_params['rpm_remote_href'] = params['rpm_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_remote_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RpmRemote',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_sync(self, rpm_remote_href, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_sync  # noqa: E501

        Trigger an asynchronous task to sync RPM content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_sync(rpm_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :param RepositorySyncURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_sync_with_http_info(rpm_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_sync_with_http_info(rpm_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_sync_with_http_info(self, rpm_remote_href, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_sync  # noqa: E501

        Trigger an asynchronous task to sync RPM content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_sync_with_http_info(rpm_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :param RepositorySyncURL data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_sync" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_remote_href' is set
        if ('rpm_remote_href' not in params or
                params['rpm_remote_href'] is None):
            raise ValueError("Missing the required parameter `rpm_remote_href` when calling `remotes_rpm_rpm_sync`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_rpm_rpm_sync`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_remote_href' in params:
            path_params['rpm_remote_href'] = params['rpm_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_remote_href}sync/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remotes_rpm_rpm_update(self, rpm_remote_href, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_update(rpm_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :param RpmRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.remotes_rpm_rpm_update_with_http_info(rpm_remote_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.remotes_rpm_rpm_update_with_http_info(rpm_remote_href, data, **kwargs)  # noqa: E501
            return data

    def remotes_rpm_rpm_update_with_http_info(self, rpm_remote_href, data, **kwargs):  # noqa: E501
        """remotes_rpm_rpm_update  # noqa: E501

        Trigger an asynchronous update task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.remotes_rpm_rpm_update_with_http_info(rpm_remote_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str rpm_remote_href: URI of Rpm Remote. e.g.: /pulp/api/v3/remotes/rpm/rpm/1/ (required)
        :param RpmRemote data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rpm_remote_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remotes_rpm_rpm_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rpm_remote_href' is set
        if ('rpm_remote_href' not in params or
                params['rpm_remote_href'] is None):
            raise ValueError("Missing the required parameter `rpm_remote_href` when calling `remotes_rpm_rpm_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `remotes_rpm_rpm_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rpm_remote_href' in params:
            path_params['rpm_remote_href'] = params['rpm_remote_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{rpm_remote_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_create(self, data, **kwargs):  # noqa: E501
        """repositories_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Repository data: (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def repositories_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """repositories_create  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Repository data: (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `repositories_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/repositories/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_delete(self, repository_href, **kwargs):  # noqa: E501
        """repositories_delete  # noqa: E501

        Trigger an asynchronous task to delete a repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_delete(repository_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_delete_with_http_info(repository_href, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_delete_with_http_info(repository_href, **kwargs)  # noqa: E501
            return data

    def repositories_delete_with_http_info(self, repository_href, **kwargs):  # noqa: E501
        """repositories_delete  # noqa: E501

        Trigger an asynchronous task to delete a repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_delete_with_http_info(repository_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_href' is set
        if ('repository_href' not in params or
                params['repository_href'] is None):
            raise ValueError("Missing the required parameter `repository_href` when calling `repositories_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_href' in params:
            path_params['repository_href'] = params['repository_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_list(self, **kwargs):  # noqa: E501
        """repositories_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.repositories_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def repositories_list_with_http_info(self, **kwargs):  # noqa: E501
        """repositories_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/repositories/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_partial_update(self, repository_href, data, **kwargs):  # noqa: E501
        """repositories_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_partial_update(repository_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param Repository data: (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_partial_update_with_http_info(repository_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_partial_update_with_http_info(repository_href, data, **kwargs)  # noqa: E501
            return data

    def repositories_partial_update_with_http_info(self, repository_href, data, **kwargs):  # noqa: E501
        """repositories_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_partial_update_with_http_info(repository_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param Repository data: (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_href' is set
        if ('repository_href' not in params or
                params['repository_href'] is None):
            raise ValueError("Missing the required parameter `repository_href` when calling `repositories_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `repositories_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_href' in params:
            path_params['repository_href'] = params['repository_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_read(self, repository_href, **kwargs):  # noqa: E501
        """repositories_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_read(repository_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_read_with_http_info(repository_href, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_read_with_http_info(repository_href, **kwargs)  # noqa: E501
            return data

    def repositories_read_with_http_info(self, repository_href, **kwargs):  # noqa: E501
        """repositories_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_read_with_http_info(repository_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_href' is set
        if ('repository_href' not in params or
                params['repository_href'] is None):
            raise ValueError("Missing the required parameter `repository_href` when calling `repositories_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_href' in params:
            path_params['repository_href'] = params['repository_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_update(self, repository_href, data, **kwargs):  # noqa: E501
        """repositories_update  # noqa: E501

        Trigger an asynchronous task to updatea repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_update(repository_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param Repository data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_update_with_http_info(repository_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_update_with_http_info(repository_href, data, **kwargs)  # noqa: E501
            return data

    def repositories_update_with_http_info(self, repository_href, data, **kwargs):  # noqa: E501
        """repositories_update  # noqa: E501

        Trigger an asynchronous task to updatea repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_update_with_http_info(repository_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param Repository data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_href' is set
        if ('repository_href' not in params or
                params['repository_href'] is None):
            raise ValueError("Missing the required parameter `repository_href` when calling `repositories_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `repositories_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_href' in params:
            path_params['repository_href'] = params['repository_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_versions_create(self, repository_href, data, **kwargs):  # noqa: E501
        """repositories_versions_create  # noqa: E501

        Trigger an asynchronous task to create a new repository version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_create(repository_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param RepositoryVersionCreate data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_versions_create_with_http_info(repository_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_versions_create_with_http_info(repository_href, data, **kwargs)  # noqa: E501
            return data

    def repositories_versions_create_with_http_info(self, repository_href, data, **kwargs):  # noqa: E501
        """repositories_versions_create  # noqa: E501

        Trigger an asynchronous task to create a new repository version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_create_with_http_info(repository_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param RepositoryVersionCreate data: (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_versions_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_href' is set
        if ('repository_href' not in params or
                params['repository_href'] is None):
            raise ValueError("Missing the required parameter `repository_href` when calling `repositories_versions_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `repositories_versions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_href' in params:
            path_params['repository_href'] = params['repository_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_href}versions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_versions_delete(self, repository_version_href, **kwargs):  # noqa: E501
        """repositories_versions_delete  # noqa: E501

        Trigger an asynchronous task to delete a repositroy version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_delete(repository_version_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_versions_delete_with_http_info(repository_version_href, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_versions_delete_with_http_info(repository_version_href, **kwargs)  # noqa: E501
            return data

    def repositories_versions_delete_with_http_info(self, repository_version_href, **kwargs):  # noqa: E501
        """repositories_versions_delete  # noqa: E501

        Trigger an asynchronous task to delete a repositroy version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_delete_with_http_info(repository_version_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :return: AsyncOperationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_versions_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_version_href' is set
        if ('repository_version_href' not in params or
                params['repository_version_href'] is None):
            raise ValueError("Missing the required parameter `repository_version_href` when calling `repositories_versions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_version_href' in params:
            path_params['repository_version_href'] = params['repository_version_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_version_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AsyncOperationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_versions_list(self, repository_href, **kwargs):  # noqa: E501
        """repositories_versions_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_list(repository_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param str ordering: Which field to use when ordering the results.
        :param float number: 
        :param float number__lt: Filter results where number is less than value
        :param float number__lte: Filter results where number is less than or equal to value
        :param float number__gt: Filter results where number is greater than value
        :param float number__gte: Filter results where number is greater than or equal to value
        :param float number__range: Filter results where number is between two comma separated values
        :param str created__lt: Filter results where _created is less than value
        :param str created__lte: Filter results where _created is less than or equal to value
        :param str created__gt: Filter results where _created is greater than value
        :param str created__gte: Filter results where _created is greater than or equal to value
        :param str created__range: Filter results where _created is between two comma separated values
        :param str content: Content Unit referenced by HREF
        :param str created: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_versions_list_with_http_info(repository_href, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_versions_list_with_http_info(repository_href, **kwargs)  # noqa: E501
            return data

    def repositories_versions_list_with_http_info(self, repository_href, **kwargs):  # noqa: E501
        """repositories_versions_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_list_with_http_info(repository_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_href: URI of Repository. e.g.: /pulp/api/v3/repositories/1/ (required)
        :param str ordering: Which field to use when ordering the results.
        :param float number: 
        :param float number__lt: Filter results where number is less than value
        :param float number__lte: Filter results where number is less than or equal to value
        :param float number__gt: Filter results where number is greater than value
        :param float number__gte: Filter results where number is greater than or equal to value
        :param float number__range: Filter results where number is between two comma separated values
        :param str created__lt: Filter results where _created is less than value
        :param str created__lte: Filter results where _created is less than or equal to value
        :param str created__gt: Filter results where _created is greater than value
        :param str created__gte: Filter results where _created is greater than or equal to value
        :param str created__range: Filter results where _created is between two comma separated values
        :param str content: Content Unit referenced by HREF
        :param str created: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_href', 'ordering', 'number', 'number__lt', 'number__lte', 'number__gt', 'number__gte', 'number__range', 'created__lt', 'created__lte', 'created__gt', 'created__gte', 'created__range', 'content', 'created', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_versions_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_href' is set
        if ('repository_href' not in params or
                params['repository_href'] is None):
            raise ValueError("Missing the required parameter `repository_href` when calling `repositories_versions_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_href' in params:
            path_params['repository_href'] = params['repository_href']  # noqa: E501

        query_params = []
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))  # noqa: E501
        if 'number' in params:
            query_params.append(('number', params['number']))  # noqa: E501
        if 'number__lt' in params:
            query_params.append(('number__lt', params['number__lt']))  # noqa: E501
        if 'number__lte' in params:
            query_params.append(('number__lte', params['number__lte']))  # noqa: E501
        if 'number__gt' in params:
            query_params.append(('number__gt', params['number__gt']))  # noqa: E501
        if 'number__gte' in params:
            query_params.append(('number__gte', params['number__gte']))  # noqa: E501
        if 'number__range' in params:
            query_params.append(('number__range', params['number__range']))  # noqa: E501
        if 'created__lt' in params:
            query_params.append(('_created__lt', params['created__lt']))  # noqa: E501
        if 'created__lte' in params:
            query_params.append(('_created__lte', params['created__lte']))  # noqa: E501
        if 'created__gt' in params:
            query_params.append(('_created__gt', params['created__gt']))  # noqa: E501
        if 'created__gte' in params:
            query_params.append(('_created__gte', params['created__gte']))  # noqa: E501
        if 'created__range' in params:
            query_params.append(('_created__range', params['created__range']))  # noqa: E501
        if 'content' in params:
            query_params.append(('content', params['content']))  # noqa: E501
        if 'created' in params:
            query_params.append(('_created', params['created']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_href}versions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_versions_partial_update(self, repository_version_href, data, **kwargs):  # noqa: E501
        """repositories_versions_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_partial_update(repository_version_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :param RepositoryVersion data: (required)
        :return: RepositoryVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_versions_partial_update_with_http_info(repository_version_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_versions_partial_update_with_http_info(repository_version_href, data, **kwargs)  # noqa: E501
            return data

    def repositories_versions_partial_update_with_http_info(self, repository_version_href, data, **kwargs):  # noqa: E501
        """repositories_versions_partial_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_partial_update_with_http_info(repository_version_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :param RepositoryVersion data: (required)
        :return: RepositoryVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_versions_partial_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_version_href' is set
        if ('repository_version_href' not in params or
                params['repository_version_href'] is None):
            raise ValueError("Missing the required parameter `repository_version_href` when calling `repositories_versions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `repositories_versions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_version_href' in params:
            path_params['repository_version_href'] = params['repository_version_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_version_href}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepositoryVersion',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_versions_read(self, repository_version_href, **kwargs):  # noqa: E501
        """repositories_versions_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_read(repository_version_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :return: RepositoryVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_versions_read_with_http_info(repository_version_href, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_versions_read_with_http_info(repository_version_href, **kwargs)  # noqa: E501
            return data

    def repositories_versions_read_with_http_info(self, repository_version_href, **kwargs):  # noqa: E501
        """repositories_versions_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_read_with_http_info(repository_version_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :return: RepositoryVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_versions_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_version_href' is set
        if ('repository_version_href' not in params or
                params['repository_version_href'] is None):
            raise ValueError("Missing the required parameter `repository_version_href` when calling `repositories_versions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_version_href' in params:
            path_params['repository_version_href'] = params['repository_version_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_version_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepositoryVersion',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_versions_update(self, repository_version_href, data, **kwargs):  # noqa: E501
        """repositories_versions_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_update(repository_version_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :param RepositoryVersion data: (required)
        :return: RepositoryVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.repositories_versions_update_with_http_info(repository_version_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_versions_update_with_http_info(repository_version_href, data, **kwargs)  # noqa: E501
            return data

    def repositories_versions_update_with_http_info(self, repository_version_href, data, **kwargs):  # noqa: E501
        """repositories_versions_update  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.repositories_versions_update_with_http_info(repository_version_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str repository_version_href: URI of Repository Version. e.g.: /pulp/api/v3/repositories/1/versions/1/ (required)
        :param RepositoryVersion data: (required)
        :return: RepositoryVersion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository_version_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_versions_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository_version_href' is set
        if ('repository_version_href' not in params or
                params['repository_version_href'] is None):
            raise ValueError("Missing the required parameter `repository_version_href` when calling `repositories_versions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `repositories_versions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository_version_href' in params:
            path_params['repository_version_href'] = params['repository_version_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{repository_version_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepositoryVersion',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def status_list(self, **kwargs):  # noqa: E501
        """status_list  # noqa: E501

        Returns app information including the version of pulpcore and loaded pulp plugins, known workers, database connection status, and messaging connection status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.status_list(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.status_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.status_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def status_list_with_http_info(self, **kwargs):  # noqa: E501
        """status_list  # noqa: E501

        Returns app information including the version of pulpcore and loaded pulp plugins, known workers, database connection status, and messaging connection status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.status_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/status/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tasks_cancel(self, task_href, data, **kwargs):  # noqa: E501
        """tasks_cancel  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_cancel(task_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_href: URI of Task. e.g.: /pulp/api/v3/tasks/1/ (required)
        :param Task data: (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.tasks_cancel_with_http_info(task_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.tasks_cancel_with_http_info(task_href, data, **kwargs)  # noqa: E501
            return data

    def tasks_cancel_with_http_info(self, task_href, data, **kwargs):  # noqa: E501
        """tasks_cancel  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_cancel_with_http_info(task_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_href: URI of Task. e.g.: /pulp/api/v3/tasks/1/ (required)
        :param Task data: (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tasks_cancel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_href' is set
        if ('task_href' not in params or
                params['task_href'] is None):
            raise ValueError("Missing the required parameter `task_href` when calling `tasks_cancel`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `tasks_cancel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_href' in params:
            path_params['task_href'] = params['task_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{task_href}cancel/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tasks_delete(self, task_href, **kwargs):  # noqa: E501
        """tasks_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_delete(task_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_href: URI of Task. e.g.: /pulp/api/v3/tasks/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.tasks_delete_with_http_info(task_href, **kwargs)  # noqa: E501
        else:
            (data) = self.tasks_delete_with_http_info(task_href, **kwargs)  # noqa: E501
            return data

    def tasks_delete_with_http_info(self, task_href, **kwargs):  # noqa: E501
        """tasks_delete  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_delete_with_http_info(task_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_href: URI of Task. e.g.: /pulp/api/v3/tasks/1/ (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tasks_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_href' is set
        if ('task_href' not in params or
                params['task_href'] is None):
            raise ValueError("Missing the required parameter `task_href` when calling `tasks_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_href' in params:
            path_params['task_href'] = params['task_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{task_href}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tasks_list(self, **kwargs):  # noqa: E501
        """tasks_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str ordering: Which field to use when ordering the results.
        :param str state: 
        :param str state__in: Filter results where state is in a comma-separated list of values
        :param str worker: Foreign Key referenced by HREF
        :param str worker__in: Filter results where worker is in a comma-separated list of values
        :param str name__contains: Filter results where name contains value
        :param str started_at__lt: Filter results where started_at is less than value
        :param str started_at__lte: Filter results where started_at is less than or equal to value
        :param str started_at__gt: Filter results where started_at is greater than value
        :param str started_at__gte: Filter results where started_at is greater than or equal to value
        :param str started_at__range: Filter results where started_at is between two comma separated values
        :param str finished_at__lt: Filter results where finished_at is less than value
        :param str finished_at__lte: Filter results where finished_at is less than or equal to value
        :param str finished_at__gt: Filter results where finished_at is greater than value
        :param str finished_at__gte: Filter results where finished_at is greater than or equal to value
        :param str finished_at__range: Filter results where finished_at is between two comma separated values
        :param str parent: Foreign Key referenced by HREF
        :param str name: 
        :param str started_at: ISO 8601 formatted dates are supported
        :param str finished_at: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.tasks_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.tasks_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def tasks_list_with_http_info(self, **kwargs):  # noqa: E501
        """tasks_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str ordering: Which field to use when ordering the results.
        :param str state: 
        :param str state__in: Filter results where state is in a comma-separated list of values
        :param str worker: Foreign Key referenced by HREF
        :param str worker__in: Filter results where worker is in a comma-separated list of values
        :param str name__contains: Filter results where name contains value
        :param str started_at__lt: Filter results where started_at is less than value
        :param str started_at__lte: Filter results where started_at is less than or equal to value
        :param str started_at__gt: Filter results where started_at is greater than value
        :param str started_at__gte: Filter results where started_at is greater than or equal to value
        :param str started_at__range: Filter results where started_at is between two comma separated values
        :param str finished_at__lt: Filter results where finished_at is less than value
        :param str finished_at__lte: Filter results where finished_at is less than or equal to value
        :param str finished_at__gt: Filter results where finished_at is greater than value
        :param str finished_at__gte: Filter results where finished_at is greater than or equal to value
        :param str finished_at__range: Filter results where finished_at is between two comma separated values
        :param str parent: Foreign Key referenced by HREF
        :param str name: 
        :param str started_at: ISO 8601 formatted dates are supported
        :param str finished_at: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ordering', 'state', 'state__in', 'worker', 'worker__in', 'name__contains', 'started_at__lt', 'started_at__lte', 'started_at__gt', 'started_at__gte', 'started_at__range', 'finished_at__lt', 'finished_at__lte', 'finished_at__gt', 'finished_at__gte', 'finished_at__range', 'parent', 'name', 'started_at', 'finished_at', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tasks_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ordering' in params:
            query_params.append(('ordering', params['ordering']))  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'state__in' in params:
            query_params.append(('state__in', params['state__in']))  # noqa: E501
        if 'worker' in params:
            query_params.append(('worker', params['worker']))  # noqa: E501
        if 'worker__in' in params:
            query_params.append(('worker__in', params['worker__in']))  # noqa: E501
        if 'name__contains' in params:
            query_params.append(('name__contains', params['name__contains']))  # noqa: E501
        if 'started_at__lt' in params:
            query_params.append(('started_at__lt', params['started_at__lt']))  # noqa: E501
        if 'started_at__lte' in params:
            query_params.append(('started_at__lte', params['started_at__lte']))  # noqa: E501
        if 'started_at__gt' in params:
            query_params.append(('started_at__gt', params['started_at__gt']))  # noqa: E501
        if 'started_at__gte' in params:
            query_params.append(('started_at__gte', params['started_at__gte']))  # noqa: E501
        if 'started_at__range' in params:
            query_params.append(('started_at__range', params['started_at__range']))  # noqa: E501
        if 'finished_at__lt' in params:
            query_params.append(('finished_at__lt', params['finished_at__lt']))  # noqa: E501
        if 'finished_at__lte' in params:
            query_params.append(('finished_at__lte', params['finished_at__lte']))  # noqa: E501
        if 'finished_at__gt' in params:
            query_params.append(('finished_at__gt', params['finished_at__gt']))  # noqa: E501
        if 'finished_at__gte' in params:
            query_params.append(('finished_at__gte', params['finished_at__gte']))  # noqa: E501
        if 'finished_at__range' in params:
            query_params.append(('finished_at__range', params['finished_at__range']))  # noqa: E501
        if 'parent' in params:
            query_params.append(('parent', params['parent']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'started_at' in params:
            query_params.append(('started_at', params['started_at']))  # noqa: E501
        if 'finished_at' in params:
            query_params.append(('finished_at', params['finished_at']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/tasks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tasks_read(self, task_href, **kwargs):  # noqa: E501
        """tasks_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_read(task_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_href: URI of Task. e.g.: /pulp/api/v3/tasks/1/ (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.tasks_read_with_http_info(task_href, **kwargs)  # noqa: E501
        else:
            (data) = self.tasks_read_with_http_info(task_href, **kwargs)  # noqa: E501
            return data

    def tasks_read_with_http_info(self, task_href, **kwargs):  # noqa: E501
        """tasks_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.tasks_read_with_http_info(task_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str task_href: URI of Task. e.g.: /pulp/api/v3/tasks/1/ (required)
        :return: Task
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tasks_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_href' is set
        if ('task_href' not in params or
                params['task_href'] is None):
            raise ValueError("Missing the required parameter `task_href` when calling `tasks_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_href' in params:
            path_params['task_href'] = params['task_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{task_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Task',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uploads_create(self, data, **kwargs):  # noqa: E501
        """uploads_create  # noqa: E501

        Handle POST requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_create(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.uploads_create_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.uploads_create_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def uploads_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """uploads_create  # noqa: E501

        Handle POST requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_create_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uploads_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `uploads_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/uploads/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uploads_create_0(self, upload_href, data, **kwargs):  # noqa: E501
        """uploads_create_0  # noqa: E501

        Handle POST requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_create_0(upload_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str upload_href: URI of Upload. e.g.: /pulp/api/v3/uploads/1/ (required)
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.uploads_create_0_with_http_info(upload_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.uploads_create_0_with_http_info(upload_href, data, **kwargs)  # noqa: E501
            return data

    def uploads_create_0_with_http_info(self, upload_href, data, **kwargs):  # noqa: E501
        """uploads_create_0  # noqa: E501

        Handle POST requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_create_0_with_http_info(upload_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str upload_href: URI of Upload. e.g.: /pulp/api/v3/uploads/1/ (required)
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['upload_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uploads_create_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'upload_href' is set
        if ('upload_href' not in params or
                params['upload_href'] is None):
            raise ValueError("Missing the required parameter `upload_href` when calling `uploads_create_0`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `uploads_create_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'upload_href' in params:
            path_params['upload_href'] = params['upload_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{upload_href}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uploads_read(self, **kwargs):  # noqa: E501
        """uploads_read  # noqa: E501

        Handle GET requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_read(async=True)
        >>> result = thread.get()

        :param async bool
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.uploads_read_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.uploads_read_with_http_info(**kwargs)  # noqa: E501
            return data

    def uploads_read_with_http_info(self, **kwargs):  # noqa: E501
        """uploads_read  # noqa: E501

        Handle GET requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_read_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uploads_read" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/uploads/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uploads_read_0(self, upload_href, **kwargs):  # noqa: E501
        """uploads_read_0  # noqa: E501

        Handle GET requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_read_0(upload_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str upload_href: URI of Upload. e.g.: /pulp/api/v3/uploads/1/ (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.uploads_read_0_with_http_info(upload_href, **kwargs)  # noqa: E501
        else:
            (data) = self.uploads_read_0_with_http_info(upload_href, **kwargs)  # noqa: E501
            return data

    def uploads_read_0_with_http_info(self, upload_href, **kwargs):  # noqa: E501
        """uploads_read_0  # noqa: E501

        Handle GET requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_read_0_with_http_info(upload_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str upload_href: URI of Upload. e.g.: /pulp/api/v3/uploads/1/ (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['upload_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uploads_read_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'upload_href' is set
        if ('upload_href' not in params or
                params['upload_href'] is None):
            raise ValueError("Missing the required parameter `upload_href` when calling `uploads_read_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'upload_href' in params:
            path_params['upload_href'] = params['upload_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{upload_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uploads_update(self, data, **kwargs):  # noqa: E501
        """uploads_update  # noqa: E501

        Handle PUT requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_update(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.uploads_update_with_http_info(data, **kwargs)  # noqa: E501
        else:
            (data) = self.uploads_update_with_http_info(data, **kwargs)  # noqa: E501
            return data

    def uploads_update_with_http_info(self, data, **kwargs):  # noqa: E501
        """uploads_update  # noqa: E501

        Handle PUT requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_update_with_http_info(data, async=True)
        >>> result = thread.get()

        :param async bool
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uploads_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `uploads_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/uploads/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uploads_update_0(self, upload_href, data, **kwargs):  # noqa: E501
        """uploads_update_0  # noqa: E501

        Handle PUT requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_update_0(upload_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str upload_href: URI of Upload. e.g.: /pulp/api/v3/uploads/1/ (required)
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.uploads_update_0_with_http_info(upload_href, data, **kwargs)  # noqa: E501
        else:
            (data) = self.uploads_update_0_with_http_info(upload_href, data, **kwargs)  # noqa: E501
            return data

    def uploads_update_0_with_http_info(self, upload_href, data, **kwargs):  # noqa: E501
        """uploads_update_0  # noqa: E501

        Handle PUT requests.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.uploads_update_0_with_http_info(upload_href, data, async=True)
        >>> result = thread.get()

        :param async bool
        :param str upload_href: URI of Upload. e.g.: /pulp/api/v3/uploads/1/ (required)
        :param Upload data: (required)
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['upload_href', 'data']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uploads_update_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'upload_href' is set
        if ('upload_href' not in params or
                params['upload_href'] is None):
            raise ValueError("Missing the required parameter `upload_href` when calling `uploads_update_0`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `uploads_update_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'upload_href' in params:
            path_params['upload_href'] = params['upload_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in params:
            body_params = params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{upload_href}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def workers_list(self, **kwargs):  # noqa: E501
        """workers_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.workers_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_heartbeat__lt: Filter results where last_heartbeat is less than value
        :param str last_heartbeat__lte: Filter results where last_heartbeat is less than or equal to value
        :param str last_heartbeat__gt: Filter results where last_heartbeat is greater than value
        :param str last_heartbeat__gte: Filter results where last_heartbeat is greater than or equal to value
        :param str last_heartbeat__range: Filter results where last_heartbeat is between two comma separated values
        :param str online: 
        :param str missing: 
        :param str last_heartbeat: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.workers_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.workers_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def workers_list_with_http_info(self, **kwargs):  # noqa: E501
        """workers_list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.workers_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: 
        :param str name__in: Filter results where name is in a comma-separated list of values
        :param str last_heartbeat__lt: Filter results where last_heartbeat is less than value
        :param str last_heartbeat__lte: Filter results where last_heartbeat is less than or equal to value
        :param str last_heartbeat__gt: Filter results where last_heartbeat is greater than value
        :param str last_heartbeat__gte: Filter results where last_heartbeat is greater than or equal to value
        :param str last_heartbeat__range: Filter results where last_heartbeat is between two comma separated values
        :param str online: 
        :param str missing: 
        :param str last_heartbeat: ISO 8601 formatted dates are supported
        :param int page: A page number within the paginated result set.
        :param int page_size: Number of results to return per page.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'name__in', 'last_heartbeat__lt', 'last_heartbeat__lte', 'last_heartbeat__gt', 'last_heartbeat__gte', 'last_heartbeat__range', 'online', 'missing', 'last_heartbeat', 'page', 'page_size']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workers_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'name__in' in params:
            query_params.append(('name__in', params['name__in']))  # noqa: E501
        if 'last_heartbeat__lt' in params:
            query_params.append(('last_heartbeat__lt', params['last_heartbeat__lt']))  # noqa: E501
        if 'last_heartbeat__lte' in params:
            query_params.append(('last_heartbeat__lte', params['last_heartbeat__lte']))  # noqa: E501
        if 'last_heartbeat__gt' in params:
            query_params.append(('last_heartbeat__gt', params['last_heartbeat__gt']))  # noqa: E501
        if 'last_heartbeat__gte' in params:
            query_params.append(('last_heartbeat__gte', params['last_heartbeat__gte']))  # noqa: E501
        if 'last_heartbeat__range' in params:
            query_params.append(('last_heartbeat__range', params['last_heartbeat__range']))  # noqa: E501
        if 'online' in params:
            query_params.append(('online', params['online']))  # noqa: E501
        if 'missing' in params:
            query_params.append(('missing', params['missing']))  # noqa: E501
        if 'last_heartbeat' in params:
            query_params.append(('last_heartbeat', params['last_heartbeat']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '/pulp/api/v3/workers/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def workers_read(self, worker_href, **kwargs):  # noqa: E501
        """workers_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.workers_read(worker_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str worker_href: URI of Worker. e.g.: /pulp/api/v3/workers/1/ (required)
        :return: Worker
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.workers_read_with_http_info(worker_href, **kwargs)  # noqa: E501
        else:
            (data) = self.workers_read_with_http_info(worker_href, **kwargs)  # noqa: E501
            return data

    def workers_read_with_http_info(self, worker_href, **kwargs):  # noqa: E501
        """workers_read  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.workers_read_with_http_info(worker_href, async=True)
        >>> result = thread.get()

        :param async bool
        :param str worker_href: URI of Worker. e.g.: /pulp/api/v3/workers/1/ (required)
        :return: Worker
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['worker_href']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workers_read" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'worker_href' is set
        if ('worker_href' not in params or
                params['worker_href'] is None):
            raise ValueError("Missing the required parameter `worker_href` when calling `workers_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'worker_href' in params:
            path_params['worker_href'] = params['worker_href']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic']  # noqa: E501

        return self.api_client.call_api(
            '{worker_href}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Worker',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
